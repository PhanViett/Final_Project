{"ast":null,"code":"/*!\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e(require(\"react\")) : \"function\" == typeof define && define.amd ? define([\"react\"], e) : \"object\" == typeof exports ? exports.CKEditor = e(require(\"react\")) : t.CKEditor = e(t.React);\n}(self, t => (() => {\n  var e = {\n    703: (t, e, r) => {\n      \"use strict\";\n\n      var o = r(414);\n\n      function n() {}\n\n      function i() {}\n\n      i.resetWarningCache = n, t.exports = function () {\n        function t(t, e, r, n, i, s) {\n          if (s !== o) {\n            var a = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types\");\n            throw a.name = \"Invariant Violation\", a;\n          }\n        }\n\n        function e() {\n          return t;\n        }\n\n        t.isRequired = t;\n        var r = {\n          array: t,\n          bigint: t,\n          bool: t,\n          func: t,\n          number: t,\n          object: t,\n          string: t,\n          symbol: t,\n          any: t,\n          arrayOf: e,\n          element: t,\n          elementType: t,\n          instanceOf: e,\n          node: t,\n          objectOf: e,\n          oneOf: e,\n          oneOfType: e,\n          shape: e,\n          exact: e,\n          checkPropTypes: i,\n          resetWarningCache: n\n        };\n        return r.PropTypes = r, r;\n      };\n    },\n    697: (t, e, r) => {\n      t.exports = r(703)();\n    },\n    414: t => {\n      \"use strict\";\n\n      t.exports = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n    },\n    787: e => {\n      \"use strict\";\n\n      e.exports = t;\n    }\n  },\n      r = {};\n\n  function o(t) {\n    var n = r[t];\n    if (void 0 !== n) return n.exports;\n    var i = r[t] = {\n      exports: {}\n    };\n    return e[t](i, i.exports, o), i.exports;\n  }\n\n  o.n = t => {\n    var e = t && t.__esModule ? () => t.default : () => t;\n    return o.d(e, {\n      a: e\n    }), e;\n  }, o.d = (t, e) => {\n    for (var r in e) o.o(e, r) && !o.o(t, r) && Object.defineProperty(t, r, {\n      enumerable: !0,\n      get: e[r]\n    });\n  }, o.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), o.r = t => {\n    \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n      value: \"Module\"\n    }), Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n  };\n  var n = {};\n  return (() => {\n    \"use strict\";\n\n    o.r(n), o.d(n, {\n      CKEditor: () => to,\n      CKEditorContext: () => Xr\n    });\n    var t = o(787),\n        e = o.n(t),\n        r = o(697),\n        i = o.n(r);\n\n    const s = function (t) {\n      var e = typeof t;\n      return null != t && (\"object\" == e || \"function\" == e);\n    };\n\n    const a = \"object\" == typeof global && global && global.Object === Object && global;\n    var c = \"object\" == typeof self && self && self.Object === Object && self;\n    const u = a || c || Function(\"return this\")();\n\n    const h = function () {\n      return u.Date.now();\n    };\n\n    var d = /\\s/;\n\n    const l = function (t) {\n      for (var e = t.length; e-- && d.test(t.charAt(e)););\n\n      return e;\n    };\n\n    var p = /^\\s+/;\n\n    const f = function (t) {\n      return t ? t.slice(0, l(t) + 1).replace(p, \"\") : t;\n    };\n\n    const _ = u.Symbol;\n    var y = Object.prototype,\n        g = y.hasOwnProperty,\n        b = y.toString,\n        v = _ ? _.toStringTag : void 0;\n\n    const m = function (t) {\n      var e = g.call(t, v),\n          r = t[v];\n\n      try {\n        t[v] = void 0;\n        var o = !0;\n      } catch (t) {}\n\n      var n = b.call(t);\n      return o && (e ? t[v] = r : delete t[v]), n;\n    };\n\n    var j = Object.prototype.toString;\n\n    const w = function (t) {\n      return j.call(t);\n    };\n\n    var x = _ ? _.toStringTag : void 0;\n\n    const E = function (t) {\n      return null == t ? void 0 === t ? \"[object Undefined]\" : \"[object Null]\" : x && x in Object(t) ? m(t) : w(t);\n    };\n\n    const O = function (t) {\n      return null != t && \"object\" == typeof t;\n    };\n\n    const C = function (t) {\n      return \"symbol\" == typeof t || O(t) && \"[object Symbol]\" == E(t);\n    };\n\n    var P = /^[-+]0x[0-9a-f]+$/i,\n        A = /^0b[01]+$/i,\n        T = /^0o[0-7]+$/i,\n        S = parseInt;\n\n    const R = function (t) {\n      if (\"number\" == typeof t) return t;\n      if (C(t)) return NaN;\n\n      if (s(t)) {\n        var e = \"function\" == typeof t.valueOf ? t.valueOf() : t;\n        t = s(e) ? e + \"\" : e;\n      }\n\n      if (\"string\" != typeof t) return 0 === t ? t : +t;\n      t = f(t);\n      var r = A.test(t);\n      return r || T.test(t) ? S(t.slice(2), r ? 2 : 8) : P.test(t) ? NaN : +t;\n    };\n\n    var W = Math.max,\n        I = Math.min;\n\n    const D = function (t, e, r) {\n      var o,\n          n,\n          i,\n          a,\n          c,\n          u,\n          d = 0,\n          l = !1,\n          p = !1,\n          f = !0;\n      if (\"function\" != typeof t) throw new TypeError(\"Expected a function\");\n\n      function _(e) {\n        var r = o,\n            i = n;\n        return o = n = void 0, d = e, a = t.apply(i, r);\n      }\n\n      function y(t) {\n        return d = t, c = setTimeout(b, e), l ? _(t) : a;\n      }\n\n      function g(t) {\n        var r = t - u;\n        return void 0 === u || r >= e || r < 0 || p && t - d >= i;\n      }\n\n      function b() {\n        var t = h();\n        if (g(t)) return v(t);\n        c = setTimeout(b, function (t) {\n          var r = e - (t - u);\n          return p ? I(r, i - (t - d)) : r;\n        }(t));\n      }\n\n      function v(t) {\n        return c = void 0, f && o ? _(t) : (o = n = void 0, a);\n      }\n\n      function m() {\n        var t = h(),\n            r = g(t);\n\n        if (o = arguments, n = this, u = t, r) {\n          if (void 0 === c) return y(u);\n          if (p) return clearTimeout(c), c = setTimeout(b, e), _(u);\n        }\n\n        return void 0 === c && (c = setTimeout(b, e)), a;\n      }\n\n      return e = R(e) || 0, s(r) && (l = !!r.leading, i = (p = \"maxWait\" in r) ? W(R(r.maxWait) || 0, e) : i, f = \"trailing\" in r ? !!r.trailing : f), m.cancel = function () {\n        void 0 !== c && clearTimeout(c), d = 0, o = u = n = c = void 0;\n      }, m.flush = function () {\n        return void 0 === c ? a : v(h());\n      }, m;\n    };\n\n    const z = function (t, e, r) {\n      var o = !0,\n          n = !0;\n      if (\"function\" != typeof t) throw new TypeError(\"Expected a function\");\n      return s(r) && (o = \"leading\" in r ? !!r.leading : o, n = \"trailing\" in r ? !!r.trailing : n), D(t, e, {\n        leading: o,\n        maxWait: e,\n        trailing: n\n      });\n    };\n\n    const M = function () {\n      this.__data__ = [], this.size = 0;\n    };\n\n    const N = function (t, e) {\n      return t === e || t != t && e != e;\n    };\n\n    const U = function (t, e) {\n      for (var r = t.length; r--;) if (N(t[r][0], e)) return r;\n\n      return -1;\n    };\n\n    var F = Array.prototype.splice;\n\n    const q = function (t) {\n      var e = this.__data__,\n          r = U(e, t);\n      return !(r < 0) && (r == e.length - 1 ? e.pop() : F.call(e, r, 1), --this.size, !0);\n    };\n\n    const k = function (t) {\n      var e = this.__data__,\n          r = U(e, t);\n      return r < 0 ? void 0 : e[r][1];\n    };\n\n    const L = function (t) {\n      return U(this.__data__, t) > -1;\n    };\n\n    const B = function (t, e) {\n      var r = this.__data__,\n          o = U(r, t);\n      return o < 0 ? (++this.size, r.push([t, e])) : r[o][1] = e, this;\n    };\n\n    function $(t) {\n      var e = -1,\n          r = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < r;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    $.prototype.clear = M, $.prototype.delete = q, $.prototype.get = k, $.prototype.has = L, $.prototype.set = B;\n    const H = $;\n\n    const V = function () {\n      this.__data__ = new H(), this.size = 0;\n    };\n\n    const K = function (t) {\n      var e = this.__data__,\n          r = e.delete(t);\n      return this.size = e.size, r;\n    };\n\n    const Q = function (t) {\n      return this.__data__.get(t);\n    };\n\n    const G = function (t) {\n      return this.__data__.has(t);\n    };\n\n    const Y = function (t) {\n      if (!s(t)) return !1;\n      var e = E(t);\n      return \"[object Function]\" == e || \"[object GeneratorFunction]\" == e || \"[object AsyncFunction]\" == e || \"[object Proxy]\" == e;\n    };\n\n    const J = u[\"__core-js_shared__\"];\n\n    var X = function () {\n      var t = /[^.]+$/.exec(J && J.keys && J.keys.IE_PROTO || \"\");\n      return t ? \"Symbol(src)_1.\" + t : \"\";\n    }();\n\n    const Z = function (t) {\n      return !!X && X in t;\n    };\n\n    var tt = Function.prototype.toString;\n\n    const et = function (t) {\n      if (null != t) {\n        try {\n          return tt.call(t);\n        } catch (t) {}\n\n        try {\n          return t + \"\";\n        } catch (t) {}\n      }\n\n      return \"\";\n    };\n\n    var rt = /^\\[object .+?Constructor\\]$/,\n        ot = Function.prototype,\n        nt = Object.prototype,\n        it = ot.toString,\n        st = nt.hasOwnProperty,\n        at = RegExp(\"^\" + it.call(st).replace(/[\\\\^$.*+?()[\\]{}|]/g, \"\\\\$&\").replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\");\n\n    const ct = function (t) {\n      return !(!s(t) || Z(t)) && (Y(t) ? at : rt).test(et(t));\n    };\n\n    const ut = function (t, e) {\n      return null == t ? void 0 : t[e];\n    };\n\n    const ht = function (t, e) {\n      var r = ut(t, e);\n      return ct(r) ? r : void 0;\n    };\n\n    const dt = ht(u, \"Map\");\n    const lt = ht(Object, \"create\");\n\n    const pt = function () {\n      this.__data__ = lt ? lt(null) : {}, this.size = 0;\n    };\n\n    const ft = function (t) {\n      var e = this.has(t) && delete this.__data__[t];\n      return this.size -= e ? 1 : 0, e;\n    };\n\n    var _t = Object.prototype.hasOwnProperty;\n\n    const yt = function (t) {\n      var e = this.__data__;\n\n      if (lt) {\n        var r = e[t];\n        return \"__lodash_hash_undefined__\" === r ? void 0 : r;\n      }\n\n      return _t.call(e, t) ? e[t] : void 0;\n    };\n\n    var gt = Object.prototype.hasOwnProperty;\n\n    const bt = function (t) {\n      var e = this.__data__;\n      return lt ? void 0 !== e[t] : gt.call(e, t);\n    };\n\n    const vt = function (t, e) {\n      var r = this.__data__;\n      return this.size += this.has(t) ? 0 : 1, r[t] = lt && void 0 === e ? \"__lodash_hash_undefined__\" : e, this;\n    };\n\n    function mt(t) {\n      var e = -1,\n          r = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < r;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    mt.prototype.clear = pt, mt.prototype.delete = ft, mt.prototype.get = yt, mt.prototype.has = bt, mt.prototype.set = vt;\n    const jt = mt;\n\n    const wt = function () {\n      this.size = 0, this.__data__ = {\n        hash: new jt(),\n        map: new (dt || H)(),\n        string: new jt()\n      };\n    };\n\n    const xt = function (t) {\n      var e = typeof t;\n      return \"string\" == e || \"number\" == e || \"symbol\" == e || \"boolean\" == e ? \"__proto__\" !== t : null === t;\n    };\n\n    const Et = function (t, e) {\n      var r = t.__data__;\n      return xt(e) ? r[\"string\" == typeof e ? \"string\" : \"hash\"] : r.map;\n    };\n\n    const Ot = function (t) {\n      var e = Et(this, t).delete(t);\n      return this.size -= e ? 1 : 0, e;\n    };\n\n    const Ct = function (t) {\n      return Et(this, t).get(t);\n    };\n\n    const Pt = function (t) {\n      return Et(this, t).has(t);\n    };\n\n    const At = function (t, e) {\n      var r = Et(this, t),\n          o = r.size;\n      return r.set(t, e), this.size += r.size == o ? 0 : 1, this;\n    };\n\n    function Tt(t) {\n      var e = -1,\n          r = null == t ? 0 : t.length;\n\n      for (this.clear(); ++e < r;) {\n        var o = t[e];\n        this.set(o[0], o[1]);\n      }\n    }\n\n    Tt.prototype.clear = wt, Tt.prototype.delete = Ot, Tt.prototype.get = Ct, Tt.prototype.has = Pt, Tt.prototype.set = At;\n    const St = Tt;\n\n    const Rt = function (t, e) {\n      var r = this.__data__;\n\n      if (r instanceof H) {\n        var o = r.__data__;\n        if (!dt || o.length < 199) return o.push([t, e]), this.size = ++r.size, this;\n        r = this.__data__ = new St(o);\n      }\n\n      return r.set(t, e), this.size = r.size, this;\n    };\n\n    function Wt(t) {\n      var e = this.__data__ = new H(t);\n      this.size = e.size;\n    }\n\n    Wt.prototype.clear = V, Wt.prototype.delete = K, Wt.prototype.get = Q, Wt.prototype.has = G, Wt.prototype.set = Rt;\n    const It = Wt;\n\n    const Dt = function (t, e) {\n      for (var r = -1, o = null == t ? 0 : t.length; ++r < o && !1 !== e(t[r], r, t););\n\n      return t;\n    };\n\n    const zt = function () {\n      try {\n        var t = ht(Object, \"defineProperty\");\n        return t({}, \"\", {}), t;\n      } catch (t) {}\n    }();\n\n    const Mt = function (t, e, r) {\n      \"__proto__\" == e && zt ? zt(t, e, {\n        configurable: !0,\n        enumerable: !0,\n        value: r,\n        writable: !0\n      }) : t[e] = r;\n    };\n\n    var Nt = Object.prototype.hasOwnProperty;\n\n    const Ut = function (t, e, r) {\n      var o = t[e];\n      Nt.call(t, e) && N(o, r) && (void 0 !== r || e in t) || Mt(t, e, r);\n    };\n\n    const Ft = function (t, e, r, o) {\n      var n = !r;\n      r || (r = {});\n\n      for (var i = -1, s = e.length; ++i < s;) {\n        var a = e[i],\n            c = o ? o(r[a], t[a], a, r, t) : void 0;\n        void 0 === c && (c = t[a]), n ? Mt(r, a, c) : Ut(r, a, c);\n      }\n\n      return r;\n    };\n\n    const qt = function (t, e) {\n      for (var r = -1, o = Array(t); ++r < t;) o[r] = e(r);\n\n      return o;\n    };\n\n    const kt = function (t) {\n      return O(t) && \"[object Arguments]\" == E(t);\n    };\n\n    var Lt = Object.prototype,\n        Bt = Lt.hasOwnProperty,\n        $t = Lt.propertyIsEnumerable;\n    const Ht = kt(function () {\n      return arguments;\n    }()) ? kt : function (t) {\n      return O(t) && Bt.call(t, \"callee\") && !$t.call(t, \"callee\");\n    };\n    const Vt = Array.isArray;\n\n    const Kt = function () {\n      return !1;\n    };\n\n    var Qt = \"object\" == typeof exports && exports && !exports.nodeType && exports,\n        Gt = Qt && \"object\" == typeof module && module && !module.nodeType && module,\n        Yt = Gt && Gt.exports === Qt ? u.Buffer : void 0;\n    const Jt = (Yt ? Yt.isBuffer : void 0) || Kt;\n    var Xt = /^(?:0|[1-9]\\d*)$/;\n\n    const Zt = function (t, e) {\n      var r = typeof t;\n      return !!(e = null == e ? 9007199254740991 : e) && (\"number\" == r || \"symbol\" != r && Xt.test(t)) && t > -1 && t % 1 == 0 && t < e;\n    };\n\n    const te = function (t) {\n      return \"number\" == typeof t && t > -1 && t % 1 == 0 && t <= 9007199254740991;\n    };\n\n    var ee = {};\n    ee[\"[object Float32Array]\"] = ee[\"[object Float64Array]\"] = ee[\"[object Int8Array]\"] = ee[\"[object Int16Array]\"] = ee[\"[object Int32Array]\"] = ee[\"[object Uint8Array]\"] = ee[\"[object Uint8ClampedArray]\"] = ee[\"[object Uint16Array]\"] = ee[\"[object Uint32Array]\"] = !0, ee[\"[object Arguments]\"] = ee[\"[object Array]\"] = ee[\"[object ArrayBuffer]\"] = ee[\"[object Boolean]\"] = ee[\"[object DataView]\"] = ee[\"[object Date]\"] = ee[\"[object Error]\"] = ee[\"[object Function]\"] = ee[\"[object Map]\"] = ee[\"[object Number]\"] = ee[\"[object Object]\"] = ee[\"[object RegExp]\"] = ee[\"[object Set]\"] = ee[\"[object String]\"] = ee[\"[object WeakMap]\"] = !1;\n\n    const re = function (t) {\n      return O(t) && te(t.length) && !!ee[E(t)];\n    };\n\n    const oe = function (t) {\n      return function (e) {\n        return t(e);\n      };\n    };\n\n    var ne = \"object\" == typeof exports && exports && !exports.nodeType && exports,\n        ie = ne && \"object\" == typeof module && module && !module.nodeType && module,\n        se = ie && ie.exports === ne && a.process;\n\n    const ae = function () {\n      try {\n        var t = ie && ie.require && ie.require(\"util\").types;\n\n        return t || se && se.binding && se.binding(\"util\");\n      } catch (t) {}\n    }();\n\n    var ce = ae && ae.isTypedArray;\n    const ue = ce ? oe(ce) : re;\n    var he = Object.prototype.hasOwnProperty;\n\n    const de = function (t, e) {\n      var r = Vt(t),\n          o = !r && Ht(t),\n          n = !r && !o && Jt(t),\n          i = !r && !o && !n && ue(t),\n          s = r || o || n || i,\n          a = s ? qt(t.length, String) : [],\n          c = a.length;\n\n      for (var u in t) !e && !he.call(t, u) || s && (\"length\" == u || n && (\"offset\" == u || \"parent\" == u) || i && (\"buffer\" == u || \"byteLength\" == u || \"byteOffset\" == u) || Zt(u, c)) || a.push(u);\n\n      return a;\n    };\n\n    var le = Object.prototype;\n\n    const pe = function (t) {\n      var e = t && t.constructor;\n      return t === (\"function\" == typeof e && e.prototype || le);\n    };\n\n    const fe = function (t, e) {\n      return function (r) {\n        return t(e(r));\n      };\n    };\n\n    const _e = fe(Object.keys, Object);\n\n    var ye = Object.prototype.hasOwnProperty;\n\n    const ge = function (t) {\n      if (!pe(t)) return _e(t);\n      var e = [];\n\n      for (var r in Object(t)) ye.call(t, r) && \"constructor\" != r && e.push(r);\n\n      return e;\n    };\n\n    const be = function (t) {\n      return null != t && te(t.length) && !Y(t);\n    };\n\n    const ve = function (t) {\n      return be(t) ? de(t) : ge(t);\n    };\n\n    const me = function (t, e) {\n      return t && Ft(e, ve(e), t);\n    };\n\n    const je = function (t) {\n      var e = [];\n      if (null != t) for (var r in Object(t)) e.push(r);\n      return e;\n    };\n\n    var we = Object.prototype.hasOwnProperty;\n\n    const xe = function (t) {\n      if (!s(t)) return je(t);\n      var e = pe(t),\n          r = [];\n\n      for (var o in t) (\"constructor\" != o || !e && we.call(t, o)) && r.push(o);\n\n      return r;\n    };\n\n    const Ee = function (t) {\n      return be(t) ? de(t, !0) : xe(t);\n    };\n\n    const Oe = function (t, e) {\n      return t && Ft(e, Ee(e), t);\n    };\n\n    var Ce = \"object\" == typeof exports && exports && !exports.nodeType && exports,\n        Pe = Ce && \"object\" == typeof module && module && !module.nodeType && module,\n        Ae = Pe && Pe.exports === Ce ? u.Buffer : void 0,\n        Te = Ae ? Ae.allocUnsafe : void 0;\n\n    const Se = function (t, e) {\n      if (e) return t.slice();\n      var r = t.length,\n          o = Te ? Te(r) : new t.constructor(r);\n      return t.copy(o), o;\n    };\n\n    const Re = function (t, e) {\n      var r = -1,\n          o = t.length;\n\n      for (e || (e = Array(o)); ++r < o;) e[r] = t[r];\n\n      return e;\n    };\n\n    const We = function (t, e) {\n      for (var r = -1, o = null == t ? 0 : t.length, n = 0, i = []; ++r < o;) {\n        var s = t[r];\n        e(s, r, t) && (i[n++] = s);\n      }\n\n      return i;\n    };\n\n    const Ie = function () {\n      return [];\n    };\n\n    var De = Object.prototype.propertyIsEnumerable,\n        ze = Object.getOwnPropertySymbols;\n    const Me = ze ? function (t) {\n      return null == t ? [] : (t = Object(t), We(ze(t), function (e) {\n        return De.call(t, e);\n      }));\n    } : Ie;\n\n    const Ne = function (t, e) {\n      return Ft(t, Me(t), e);\n    };\n\n    const Ue = function (t, e) {\n      for (var r = -1, o = e.length, n = t.length; ++r < o;) t[n + r] = e[r];\n\n      return t;\n    };\n\n    const Fe = fe(Object.getPrototypeOf, Object);\n    const qe = Object.getOwnPropertySymbols ? function (t) {\n      for (var e = []; t;) Ue(e, Me(t)), t = Fe(t);\n\n      return e;\n    } : Ie;\n\n    const ke = function (t, e) {\n      return Ft(t, qe(t), e);\n    };\n\n    const Le = function (t, e, r) {\n      var o = e(t);\n      return Vt(t) ? o : Ue(o, r(t));\n    };\n\n    const Be = function (t) {\n      return Le(t, ve, Me);\n    };\n\n    const $e = function (t) {\n      return Le(t, Ee, qe);\n    };\n\n    const He = ht(u, \"DataView\");\n    const Ve = ht(u, \"Promise\");\n    const Ke = ht(u, \"Set\");\n    const Qe = ht(u, \"WeakMap\");\n    var Ge = \"[object Map]\",\n        Ye = \"[object Promise]\",\n        Je = \"[object Set]\",\n        Xe = \"[object WeakMap]\",\n        Ze = \"[object DataView]\",\n        tr = et(He),\n        er = et(dt),\n        rr = et(Ve),\n        or = et(Ke),\n        nr = et(Qe),\n        ir = E;\n    (He && ir(new He(new ArrayBuffer(1))) != Ze || dt && ir(new dt()) != Ge || Ve && ir(Ve.resolve()) != Ye || Ke && ir(new Ke()) != Je || Qe && ir(new Qe()) != Xe) && (ir = function (t) {\n      var e = E(t),\n          r = \"[object Object]\" == e ? t.constructor : void 0,\n          o = r ? et(r) : \"\";\n      if (o) switch (o) {\n        case tr:\n          return Ze;\n\n        case er:\n          return Ge;\n\n        case rr:\n          return Ye;\n\n        case or:\n          return Je;\n\n        case nr:\n          return Xe;\n      }\n      return e;\n    });\n    const sr = ir;\n    var ar = Object.prototype.hasOwnProperty;\n\n    const cr = function (t) {\n      var e = t.length,\n          r = new t.constructor(e);\n      return e && \"string\" == typeof t[0] && ar.call(t, \"index\") && (r.index = t.index, r.input = t.input), r;\n    };\n\n    const ur = u.Uint8Array;\n\n    const hr = function (t) {\n      var e = new t.constructor(t.byteLength);\n      return new ur(e).set(new ur(t)), e;\n    };\n\n    const dr = function (t, e) {\n      var r = e ? hr(t.buffer) : t.buffer;\n      return new t.constructor(r, t.byteOffset, t.byteLength);\n    };\n\n    var lr = /\\w*$/;\n\n    const pr = function (t) {\n      var e = new t.constructor(t.source, lr.exec(t));\n      return e.lastIndex = t.lastIndex, e;\n    };\n\n    var fr = _ ? _.prototype : void 0,\n        _r = fr ? fr.valueOf : void 0;\n\n    const yr = function (t) {\n      return _r ? Object(_r.call(t)) : {};\n    };\n\n    const gr = function (t, e) {\n      var r = e ? hr(t.buffer) : t.buffer;\n      return new t.constructor(r, t.byteOffset, t.length);\n    };\n\n    const br = function (t, e, r) {\n      var o = t.constructor;\n\n      switch (e) {\n        case \"[object ArrayBuffer]\":\n          return hr(t);\n\n        case \"[object Boolean]\":\n        case \"[object Date]\":\n          return new o(+t);\n\n        case \"[object DataView]\":\n          return dr(t, r);\n\n        case \"[object Float32Array]\":\n        case \"[object Float64Array]\":\n        case \"[object Int8Array]\":\n        case \"[object Int16Array]\":\n        case \"[object Int32Array]\":\n        case \"[object Uint8Array]\":\n        case \"[object Uint8ClampedArray]\":\n        case \"[object Uint16Array]\":\n        case \"[object Uint32Array]\":\n          return gr(t, r);\n\n        case \"[object Map]\":\n        case \"[object Set]\":\n          return new o();\n\n        case \"[object Number]\":\n        case \"[object String]\":\n          return new o(t);\n\n        case \"[object RegExp]\":\n          return pr(t);\n\n        case \"[object Symbol]\":\n          return yr(t);\n      }\n    };\n\n    var vr = Object.create;\n\n    const mr = function () {\n      function t() {}\n\n      return function (e) {\n        if (!s(e)) return {};\n        if (vr) return vr(e);\n        t.prototype = e;\n        var r = new t();\n        return t.prototype = void 0, r;\n      };\n    }();\n\n    const jr = function (t) {\n      return \"function\" != typeof t.constructor || pe(t) ? {} : mr(Fe(t));\n    };\n\n    const wr = function (t) {\n      return O(t) && \"[object Map]\" == sr(t);\n    };\n\n    var xr = ae && ae.isMap;\n    const Er = xr ? oe(xr) : wr;\n\n    const Or = function (t) {\n      return O(t) && \"[object Set]\" == sr(t);\n    };\n\n    var Cr = ae && ae.isSet;\n    const Pr = Cr ? oe(Cr) : Or;\n    var Ar = \"[object Arguments]\",\n        Tr = \"[object Function]\",\n        Sr = \"[object Object]\",\n        Rr = {};\n    Rr[Ar] = Rr[\"[object Array]\"] = Rr[\"[object ArrayBuffer]\"] = Rr[\"[object DataView]\"] = Rr[\"[object Boolean]\"] = Rr[\"[object Date]\"] = Rr[\"[object Float32Array]\"] = Rr[\"[object Float64Array]\"] = Rr[\"[object Int8Array]\"] = Rr[\"[object Int16Array]\"] = Rr[\"[object Int32Array]\"] = Rr[\"[object Map]\"] = Rr[\"[object Number]\"] = Rr[\"[object Object]\"] = Rr[\"[object RegExp]\"] = Rr[\"[object Set]\"] = Rr[\"[object String]\"] = Rr[\"[object Symbol]\"] = Rr[\"[object Uint8Array]\"] = Rr[\"[object Uint8ClampedArray]\"] = Rr[\"[object Uint16Array]\"] = Rr[\"[object Uint32Array]\"] = !0, Rr[\"[object Error]\"] = Rr[Tr] = Rr[\"[object WeakMap]\"] = !1;\n\n    const Wr = function t(e, r, o, n, i, a) {\n      var c,\n          u = 1 & r,\n          h = 2 & r,\n          d = 4 & r;\n      if (o && (c = i ? o(e, n, i, a) : o(e)), void 0 !== c) return c;\n      if (!s(e)) return e;\n      var l = Vt(e);\n\n      if (l) {\n        if (c = cr(e), !u) return Re(e, c);\n      } else {\n        var p = sr(e),\n            f = p == Tr || \"[object GeneratorFunction]\" == p;\n        if (Jt(e)) return Se(e, u);\n\n        if (p == Sr || p == Ar || f && !i) {\n          if (c = h || f ? {} : jr(e), !u) return h ? ke(e, Oe(c, e)) : Ne(e, me(c, e));\n        } else {\n          if (!Rr[p]) return i ? e : {};\n          c = br(e, p, u);\n        }\n      }\n\n      a || (a = new It());\n\n      var _ = a.get(e);\n\n      if (_) return _;\n      a.set(e, c), Pr(e) ? e.forEach(function (n) {\n        c.add(t(n, r, o, n, e, a));\n      }) : Er(e) && e.forEach(function (n, i) {\n        c.set(i, t(n, r, o, i, e, a));\n      });\n      var y = l ? void 0 : (d ? h ? $e : Be : h ? Ee : ve)(e);\n      return Dt(y || e, function (n, i) {\n        y && (n = e[i = n]), Ut(c, i, t(n, r, o, i, e, a));\n      }), c;\n    };\n\n    const Ir = function (t, e) {\n      return Wr(t, 5, e = \"function\" == typeof e ? e : void 0);\n    };\n\n    var Dr = Function.prototype,\n        zr = Object.prototype,\n        Mr = Dr.toString,\n        Nr = zr.hasOwnProperty,\n        Ur = Mr.call(Object);\n\n    const Fr = function (t) {\n      if (!O(t) || \"[object Object]\" != E(t)) return !1;\n      var e = Fe(t);\n      if (null === e) return !0;\n      var r = Nr.call(e, \"constructor\") && e.constructor;\n      return \"function\" == typeof r && r instanceof r && Mr.call(r) == Ur;\n    };\n\n    const qr = function (t) {\n      return O(t) && 1 === t.nodeType && !Fr(t);\n    };\n\n    function kr(t) {\n      let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n      const r = [t],\n            o = new Set();\n      let n = 0;\n\n      for (; r.length > n;) {\n        const t = r[n++];\n        if (!(o.has(t) || Lr(t) || e.has(t))) if (o.add(t), t[Symbol.iterator]) try {\n          for (const e of t) r.push(e);\n        } catch (t) {} else for (const e in t) \"defaultValue\" !== e && r.push(t[e]);\n      }\n\n      return o;\n    }\n\n    function Lr(t) {\n      const e = Object.prototype.toString.call(t),\n            r = typeof t;\n      return \"number\" === r || \"boolean\" === r || \"string\" === r || \"symbol\" === r || \"function\" === r || \"[object Date]\" === e || \"[object RegExp]\" === e || \"[object Module]\" === e || null == t || t instanceof EventTarget || t instanceof Event;\n    }\n\n    function Br(t, e) {\n      let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();\n      if (t === e && \"object\" == typeof (o = t) && null !== o) return !0;\n      var o;\n      const n = kr(t, r),\n            i = kr(e, r);\n\n      for (const t of n) if (i.has(t)) return !0;\n\n      return !1;\n    }\n\n    class $r {\n      constructor(t) {\n        if (this.crashes = [], this.state = \"initializing\", this._crashNumberLimit = \"number\" == typeof t.crashNumberLimit ? t.crashNumberLimit : 3, this._now = Date.now, this._minimumNonErrorTimePeriod = \"number\" == typeof t.minimumNonErrorTimePeriod ? t.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = t => {\n          const e = t.error || t.reason;\n          e instanceof Error && this._handleError(e, t);\n        }, this._listeners = {}, !this._restart) throw new Error(\"The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.\");\n      }\n\n      setCreator(t) {\n        this._creator = t;\n      }\n\n      setDestructor(t) {\n        this._destructor = t;\n      }\n\n      destroy() {\n        this._stopErrorHandling(), this._listeners = {};\n      }\n\n      on(t, e) {\n        this._listeners[t] || (this._listeners[t] = []), this._listeners[t].push(e);\n      }\n\n      off(t, e) {\n        this._listeners[t] = this._listeners[t].filter(t => t !== e);\n      }\n\n      _fire(t) {\n        const r = this._listeners[t] || [];\n\n        for (var _len = arguments.length, e = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          e[_key - 1] = arguments[_key];\n        }\n\n        for (const t of r) t.apply(this, [null, ...e]);\n      }\n\n      _startErrorHandling() {\n        window.addEventListener(\"error\", this._boundErrorHandler), window.addEventListener(\"unhandledrejection\", this._boundErrorHandler);\n      }\n\n      _stopErrorHandling() {\n        window.removeEventListener(\"error\", this._boundErrorHandler), window.removeEventListener(\"unhandledrejection\", this._boundErrorHandler);\n      }\n\n      _handleError(t, e) {\n        if (this._shouldReactToError(t)) {\n          this.crashes.push({\n            message: t.message,\n            stack: t.stack,\n            filename: e.filename,\n            lineno: e.lineno,\n            colno: e.colno,\n            date: this._now()\n          });\n\n          const r = this._shouldRestart();\n\n          this.state = \"crashed\", this._fire(\"stateChange\"), this._fire(\"error\", {\n            error: t,\n            causesRestart: r\n          }), r ? this._restart() : (this.state = \"crashedPermanently\", this._fire(\"stateChange\"));\n        }\n      }\n\n      _shouldReactToError(t) {\n        return t.is && t.is(\"CKEditorError\") && void 0 !== t.context && null !== t.context && \"ready\" === this.state && this._isErrorComingFromThisItem(t);\n      }\n\n      _shouldRestart() {\n        if (this.crashes.length <= this._crashNumberLimit) return !0;\n        return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;\n      }\n\n    }\n\n    class Hr extends $r {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(e), this._editor = null, this._throttledSave = z(this._save.bind(this), \"number\" == typeof e.saveInterval ? e.saveInterval : 5e3), this._creator = (e, r) => t.create(e, r), this._destructor = t => t.destroy();\n      }\n\n      get editor() {\n        return this._editor;\n      }\n\n      get _item() {\n        return this._editor;\n      }\n\n      _restart() {\n        return Promise.resolve().then(() => (this.state = \"initializing\", this._fire(\"stateChange\"), this._destroy())).catch(t => {\n          console.error(\"An error happened during the editor destroying.\", t);\n        }).then(() => {\n          if (\"string\" == typeof this._elementOrData) return this.create(this._data, this._config, this._config.context);\n          {\n            const t = Object.assign({}, this._config, {\n              initialData: this._data\n            });\n            return this.create(this._elementOrData, t, t.context);\n          }\n        }).then(() => {\n          this._fire(\"restart\");\n        });\n      }\n\n      create() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._elementOrData;\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._config;\n        let r = arguments.length > 2 ? arguments[2] : undefined;\n        return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = t, this._config = this._cloneEditorConfiguration(e) || {}, this._config.context = r, this._creator(t, this._config))).then(t => {\n          this._editor = t, t.model.document.on(\"change:data\", this._throttledSave), this._lastDocumentVersion = t.model.document.version, this._data = this._getData(), this.state = \"ready\", this._fire(\"stateChange\");\n        });\n      }\n\n      destroy() {\n        return Promise.resolve().then(() => (this.state = \"destroyed\", this._fire(\"stateChange\"), super.destroy(), this._destroy()));\n      }\n\n      _destroy() {\n        return Promise.resolve().then(() => {\n          this._stopErrorHandling(), this._throttledSave.flush();\n          const t = this._editor;\n          return this._editor = null, t.model.document.off(\"change:data\", this._throttledSave), this._destructor(t);\n        });\n      }\n\n      _save() {\n        const t = this._editor.model.document.version;\n\n        try {\n          this._data = this._getData(), this._lastDocumentVersion = t;\n        } catch (t) {\n          console.error(t, \"An error happened during restoring editor data. Editor will be restored from the previously saved data.\");\n        }\n      }\n\n      _setExcludedProperties(t) {\n        this._excludedProps = t;\n      }\n\n      _getData() {\n        const t = {};\n\n        for (const e of this._editor.model.document.getRootNames()) t[e] = this._editor.data.get({\n          rootName: e\n        });\n\n        return t;\n      }\n\n      _isErrorComingFromThisItem(t) {\n        return Br(this._editor, t.context, this._excludedProps);\n      }\n\n      _cloneEditorConfiguration(t) {\n        return Ir(t, (t, e) => qr(t) || \"context\" === e ? t : void 0);\n      }\n\n    }\n\n    const Vr = new Array(256).fill().map((t, e) => (\"0\" + e.toString(16)).slice(-2));\n    const Kr = Symbol(\"MainQueueId\");\n\n    class Qr extends $r {\n      constructor(t) {\n        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        super(e), this._watchdogs = new Map(), this._watchdogConfig = e, this._context = null, this._contextProps = new Set(), this._actionQueues = new Gr(), this._creator = e => t.create(e), this._destructor = t => t.destroy(), this._actionQueues.onEmpty(() => {\n          \"initializing\" === this.state && (this.state = \"ready\", this._fire(\"stateChange\"));\n        });\n      }\n\n      get context() {\n        return this._context;\n      }\n\n      create() {\n        let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        return this._actionQueues.enqueue(Kr, () => (this._contextConfig = t, this._create()));\n      }\n\n      getItem(t) {\n        return this._getWatchdog(t)._item;\n      }\n\n      getItemState(t) {\n        return this._getWatchdog(t).state;\n      }\n\n      add(t) {\n        const e = Yr(t);\n        return Promise.all(e.map(t => this._actionQueues.enqueue(t.id, () => {\n          if (\"destroyed\" === this.state) throw new Error(\"Cannot add items to destroyed watchdog.\");\n          if (!this._context) throw new Error(\"Context was not created yet. You should call the `ContextWatchdog#create()` method first.\");\n          let e;\n          if (this._watchdogs.has(t.id)) throw new Error(`Item with the given id is already added: '${t.id}'.`);\n          if (\"editor\" === t.type) return e = new Hr(this._watchdogConfig), e.setCreator(t.creator), e._setExcludedProperties(this._contextProps), t.destructor && e.setDestructor(t.destructor), this._watchdogs.set(t.id, e), e.on(\"error\", (r, _ref) => {\n            let {\n              error: o,\n              causesRestart: n\n            } = _ref;\n            this._fire(\"itemError\", {\n              itemId: t.id,\n              error: o\n            }), n && this._actionQueues.enqueue(t.id, () => new Promise(r => {\n              e.on(\"restart\", function o() {\n                e.off(\"restart\", o), this._fire(\"itemRestart\", {\n                  itemId: t.id\n                }), r();\n              }.bind(this));\n            }));\n          }), e.create(t.sourceElementOrData, t.config, this._context);\n          throw new Error(`Not supported item type: '${t.type}'.`);\n        })));\n      }\n\n      remove(t) {\n        const e = Yr(t);\n        return Promise.all(e.map(t => this._actionQueues.enqueue(t, () => {\n          const e = this._getWatchdog(t);\n\n          return this._watchdogs.delete(t), e.destroy();\n        })));\n      }\n\n      destroy() {\n        return this._actionQueues.enqueue(Kr, () => (this.state = \"destroyed\", this._fire(\"stateChange\"), super.destroy(), this._destroy()));\n      }\n\n      _restart() {\n        return this._actionQueues.enqueue(Kr, () => (this.state = \"initializing\", this._fire(\"stateChange\"), this._destroy().catch(t => {\n          console.error(\"An error happened during destroying the context or items.\", t);\n        }).then(() => this._create()).then(() => this._fire(\"restart\"))));\n      }\n\n      _create() {\n        return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then(t => (this._context = t, this._contextProps = kr(this._context), Promise.all(Array.from(this._watchdogs.values()).map(t => (t._setExcludedProperties(this._contextProps), t.create(void 0, void 0, this._context))))));\n      }\n\n      _destroy() {\n        return Promise.resolve().then(() => {\n          this._stopErrorHandling();\n\n          const t = this._context;\n          return this._context = null, this._contextProps = new Set(), Promise.all(Array.from(this._watchdogs.values()).map(t => t.destroy())).then(() => this._destructor(t));\n        });\n      }\n\n      _getWatchdog(t) {\n        const e = this._watchdogs.get(t);\n\n        if (!e) throw new Error(`Item with the given id was not registered: ${t}.`);\n        return e;\n      }\n\n      _isErrorComingFromThisItem(t) {\n        for (const e of this._watchdogs.values()) if (e._isErrorComingFromThisItem(t)) return !1;\n\n        return Br(this._context, t.context);\n      }\n\n    }\n\n    class Gr {\n      constructor() {\n        this._onEmptyCallbacks = [], this._queues = new Map(), this._actions = new WeakMap(), this._lastActionId = 0, this._activeActions = 0;\n      }\n\n      onEmpty(t) {\n        this._onEmptyCallbacks.push(t);\n      }\n\n      enqueue(t, e) {\n        const r = t === Kr;\n        this._activeActions++, this._queues.get(t) || this._queues.set(t, Promise.resolve());\n        const o = (r ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Kr), this._queues.get(t)])).then(e),\n              n = o.catch(() => {});\n        return this._queues.set(t, n), o.finally(() => {\n          this._activeActions--, this._queues.get(t) === n && 0 === this._activeActions && this._onEmptyCallbacks.forEach(t => t());\n        });\n      }\n\n    }\n\n    function Yr(t) {\n      return Array.isArray(t) ? t : [t];\n    }\n\n    const Jr = e().createContext(\"contextWatchdog\");\n\n    class Xr extends e().Component {\n      constructor(t, e) {\n        super(t, e), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);\n      }\n\n      async shouldComponentUpdate(t) {\n        return t.id !== this.props.id && (this.contextWatchdog && (await this.contextWatchdog.destroy()), await this._initializeContextWatchdog(t.config)), t.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t.config), !0) : this.props.children !== t.children;\n      }\n\n      render() {\n        return e().createElement(Jr.Provider, {\n          value: this.contextWatchdog\n        }, this.props.children);\n      }\n\n      async componentWillUnmount() {\n        await this._destroyContext();\n      }\n\n      async _initializeContextWatchdog(t) {\n        this.contextWatchdog = new Qr(this.props.context), this.contextWatchdog.on(\"error\", (t, e) => {\n          this.props.onError(e.error, {\n            phase: \"runtime\",\n            willContextRestart: e.causesRestart\n          });\n        }), this.contextWatchdog.on(\"stateChange\", () => {\n          \"ready\" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);\n        }), await this.contextWatchdog.create(t).catch(t => {\n          this.props.onError(t, {\n            phase: \"initialization\",\n            willContextRestart: !1\n          });\n        });\n      }\n\n      async _destroyContext() {\n        this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);\n      }\n\n    }\n\n    Xr.defaultProps = {\n      isLayoutReady: !0,\n      onError: (t, e) => console.error(t, e)\n    }, Xr.propTypes = {\n      id: i().string,\n      isLayoutReady: i().bool,\n      context: i().func,\n      config: i().object,\n      onReady: i().func,\n      onError: i().func\n    };\n    const Zr = \"Lock from React integration (@ckeditor/ckeditor5-react)\";\n\n    class to extends e().Component {\n      constructor(t) {\n        super(t), this.domContainer = e().createRef(), this.watchdog = null;\n        const {\n          CKEDITOR_VERSION: r\n        } = window;\n\n        if (r) {\n          const [t] = r.split(\".\").map(Number);\n          t < 34 && console.warn(\"The <CKEditor> component requires using CKEditor 5 in version 34 or higher.\");\n        } else console.warn('Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.');\n      }\n\n      get editor() {\n        return this.watchdog ? this.watchdog.editor : null;\n      }\n\n      shouldComponentUpdate(t) {\n        return !!this.editor && (t.id !== this.props.id || (this._shouldUpdateEditor(t) && this.editor.setData(t.data), \"disabled\" in t && (t.disabled ? this.editor.enableReadOnlyMode(Zr) : this.editor.disableReadOnlyMode(Zr)), !1));\n      }\n\n      async componentDidMount() {\n        await this._initializeEditor();\n      }\n\n      async componentDidUpdate() {\n        await this._destroyEditor(), await this._initializeEditor();\n      }\n\n      async componentWillUnmount() {\n        await this._destroyEditor();\n      }\n\n      render() {\n        return e().createElement(\"div\", {\n          ref: this.domContainer\n        });\n      }\n\n      async _initializeEditor() {\n        this.watchdog || (this.context instanceof Qr ? this.watchdog = new eo(this.context) : this.watchdog = new to._EditorWatchdog(this.props.editor), this.watchdog.setCreator((t, e) => this._createEditor(t, e)), this.watchdog.on(\"error\", (t, _ref2) => {\n          let {\n            error: e,\n            causesRestart: r\n          } = _ref2;\n          this.props.onError(e, {\n            phase: \"runtime\",\n            willEditorRestart: r\n          });\n        }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch(t => this.props.onError(t, {\n          phase: \"initialization\",\n          willEditorRestart: !1\n        })));\n      }\n\n      _createEditor(t, e) {\n        return this.props.editor.create(t, e).then(t => {\n          \"disabled\" in this.props && this.props.disabled && t.enableReadOnlyMode(Zr);\n          const e = t.model.document,\n                r = t.editing.view.document;\n          return e.on(\"change:data\", e => {\n            this.props.onChange && this.props.onChange(e, t);\n          }), r.on(\"focus\", e => {\n            this.props.onFocus && this.props.onFocus(e, t);\n          }), r.on(\"blur\", e => {\n            this.props.onBlur && this.props.onBlur(e, t);\n          }), setTimeout(() => {\n            this.props.onReady && this.props.onReady(this.editor);\n          }), t;\n        });\n      }\n\n      async _destroyEditor() {\n        this.editor && (await this.watchdog.destroy(), this.watchdog = null);\n      }\n\n      _shouldUpdateEditor(t) {\n        return this.props.data !== t.data && this.editor.getData() !== t.data;\n      }\n\n      _getConfig() {\n        return this.props.data && this.props.config.initialData && console.warn(\"Editor data should be provided either using `config.initialData` or `data` properties. The config property is over the data value and the first one will be used when specified both.\"), { ...this.props.config,\n          initialData: this.props.config.initialData || this.props.data || \"\"\n        };\n      }\n\n    }\n\n    class eo {\n      constructor(t) {\n        this._contextWatchdog = t, this._id = function () {\n          const t = 4294967296 * Math.random() >>> 0,\n                e = 4294967296 * Math.random() >>> 0,\n                r = 4294967296 * Math.random() >>> 0,\n                o = 4294967296 * Math.random() >>> 0;\n          return \"e\" + Vr[t >> 0 & 255] + Vr[t >> 8 & 255] + Vr[t >> 16 & 255] + Vr[t >> 24 & 255] + Vr[e >> 0 & 255] + Vr[e >> 8 & 255] + Vr[e >> 16 & 255] + Vr[e >> 24 & 255] + Vr[r >> 0 & 255] + Vr[r >> 8 & 255] + Vr[r >> 16 & 255] + Vr[r >> 24 & 255] + Vr[o >> 0 & 255] + Vr[o >> 8 & 255] + Vr[o >> 16 & 255] + Vr[o >> 24 & 255];\n        }();\n      }\n\n      setCreator(t) {\n        this._creator = t;\n      }\n\n      create(t, e) {\n        return this._contextWatchdog.add({\n          sourceElementOrData: t,\n          config: e,\n          creator: this._creator,\n          id: this._id,\n          type: \"editor\"\n        });\n      }\n\n      on(t, e) {\n        this._contextWatchdog.on(\"itemError\", (t, _ref3) => {\n          let {\n            itemId: r,\n            causesRestart: o,\n            error: n\n          } = _ref3;\n          r === this._id && e(null, {\n            error: n,\n            causesRestart: o\n          });\n        });\n      }\n\n      destroy() {\n        this._contextWatchdog.remove(this._id);\n      }\n\n      get editor() {\n        return this._contextWatchdog.getItem(this._id);\n      }\n\n    }\n\n    to.contextType = Jr, to.propTypes = {\n      editor: i().func.isRequired,\n      data: i().string,\n      config: i().object,\n      onChange: i().func,\n      onReady: i().func,\n      onFocus: i().func,\n      onBlur: i().func,\n      onError: i().func,\n      disabled: i().bool,\n      onInit: (t, e) => {\n        if (t[e]) return new Error('The \"onInit\" property is not supported anymore by the CKEditor component. Use the \"onReady\" property instead.');\n      }\n    }, to.defaultProps = {\n      config: {},\n      onError: (t, e) => console.error(t, e)\n    }, to._EditorWatchdog = Hr;\n  })(), n;\n})()); //# sourceMappingURL=ckeditor.js.map","map":null,"metadata":{},"sourceType":"script"}