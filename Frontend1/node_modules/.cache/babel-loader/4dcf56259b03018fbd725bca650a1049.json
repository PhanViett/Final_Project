{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PartitionRelativeTimePattern = void 0;\n\nvar ecma402_abstract_1 = require(\"@formatjs/ecma402-abstract\");\n\nvar SingularRelativeTimeUnit_1 = require(\"./SingularRelativeTimeUnit\");\n\nvar MakePartsList_1 = require(\"./MakePartsList\");\n\nfunction PartitionRelativeTimePattern(rtf, value, unit, _a) {\n  var getInternalSlots = _a.getInternalSlots;\n  (0, ecma402_abstract_1.invariant)((0, ecma402_abstract_1.Type)(value) === 'Number', \"value must be number, instead got \".concat(typeof value), TypeError);\n  (0, ecma402_abstract_1.invariant)((0, ecma402_abstract_1.Type)(unit) === 'String', \"unit must be number, instead got \".concat(typeof value), TypeError);\n\n  if (isNaN(value) || !isFinite(value)) {\n    throw new RangeError(\"Invalid value \".concat(value));\n  }\n\n  var resolvedUnit = (0, SingularRelativeTimeUnit_1.SingularRelativeTimeUnit)(unit);\n\n  var _b = getInternalSlots(rtf),\n      fields = _b.fields,\n      style = _b.style,\n      numeric = _b.numeric,\n      pluralRules = _b.pluralRules,\n      numberFormat = _b.numberFormat;\n\n  var entry = resolvedUnit;\n\n  if (style === 'short') {\n    entry = \"\".concat(resolvedUnit, \"-short\");\n  } else if (style === 'narrow') {\n    entry = \"\".concat(resolvedUnit, \"-narrow\");\n  }\n\n  if (!(entry in fields)) {\n    entry = resolvedUnit;\n  }\n\n  var patterns = fields[entry];\n\n  if (numeric === 'auto') {\n    if ((0, ecma402_abstract_1.ToString)(value) in patterns) {\n      return [{\n        type: 'literal',\n        value: patterns[(0, ecma402_abstract_1.ToString)(value)]\n      }];\n    }\n  }\n\n  var tl = 'future';\n\n  if ((0, ecma402_abstract_1.SameValue)(value, -0) || value < 0) {\n    tl = 'past';\n  }\n\n  var po = patterns[tl];\n  var fv = typeof numberFormat.formatToParts === 'function' ? numberFormat.formatToParts(Math.abs(value)) : // TODO: If formatToParts is not supported, we assume the whole formatted\n  // number is a part\n  [{\n    type: 'literal',\n    value: numberFormat.format(Math.abs(value)),\n    unit: unit\n  }];\n  var pr = pluralRules.select(value);\n  var pattern = po[pr];\n  return (0, MakePartsList_1.MakePartsList)(pattern, resolvedUnit, fv);\n}\n\nexports.PartitionRelativeTimePattern = PartitionRelativeTimePattern;","map":null,"metadata":{},"sourceType":"script"}